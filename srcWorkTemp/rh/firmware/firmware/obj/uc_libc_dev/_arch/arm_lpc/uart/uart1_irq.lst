   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"uart1_irq.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.uart1_Init,"ax",%progbits
  19              		.align	1
  20              		.global	uart1_Init
  21              		.thumb
  22              		.thumb_func
  24              	uart1_Init:
  25              	.LFB0:
  26              		.file 1 "uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c"
   1:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** /*
   2:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	ESTA BIBLIOTECA NÃO TRATA OS ERROS DE RECEPÇÃO PE, OE, FE E BI NAS INTERRUPÇÕES
   3:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	Logo as interrupções rx line (U0IER_ELSI) e as interrupções responsável pelo modem estão desativad
   4:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	
   5:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	1 - SE NÃO USARMOS CONRTROLE DE FLUXO devemos levar em consideração o estouro da buffer
   6:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		de recepção para onde o ARM está trasmitindo
   7:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		se transmitirmos muitos dados em um baudrate elevado, o buffer do destino pode estourar e
   8:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		pode aperece que o problema seja nas nossas bibliotecas. então
   9:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		aumente o buffer rx do destino, ou aumente a prioridade de recepção
  10:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		ou diminuia o baudrate em uma taxa mais adequada
  11:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
  12:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	A interrupção de transmissão é gerada a cada 16 bytes transmitidos, ou seja, quando a FIFO TX esti
  13:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	A interrupção de recepção é gerada, na pior das hipóteses, a cada byte recebido; isto porque podem
  14:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	o nível da FIFO RX (trigger) para que a interrupção seja gerada.
  15:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
  16:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	Como a UART não é tão rápida assim e não há tanto fluxo de dados pela UART, as interrupções não sã
  17:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	subsequentemente dando tempo de sobra para outras funções da CPU.
  18:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** */
  19:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
  20:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** #include "uart1_irq.h"
  21:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** #include "vic.h"	
  22:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** #if defined(cortexm3)
  23:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** #include "arm.h"
  24:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** #endif
  25:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
  26:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** static volatile u8 u1_tx_running;						// Indicador se existe dados sendo transmitidos na UART
  27:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** static volatile u16 u1_overflow_rx;						// Contador de estouro do buffer de recepção
  28:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	
  29:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // BUFFERS DE RECEPÇÃO E TRANSMISSÃO
  30:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** static volatile buffer_t u1_buf_rx; 					// Cria uma estrutura do buffer de recepção
  31:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** static volatile buffer_t u1_buf_tx;						// Cria uma estrutura do buffer de transmissão
  32:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	
  33:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** #if (USE_MALLOC == pdON)
  34:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	static u8 *u1_data_rx;								// Ponteiro para alocação de memória para o buffer de recepção
  35:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	static u8 *u1_data_tx;								// Ponteiro para alocação de memória para o buffer de transmissão
  36:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** #else
  37:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	static u8 u1_data_rx[UART1_RX_BUFFER_SIZE];			// Alocação de memória automática para o buffer de r
  38:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	static u8 u1_data_tx[UART1_TX_BUFFER_SIZE];			// Alocação de memória automática para o buffer de t
  39:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** #endif
  40:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		
  41:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** void uart1_ISR (void);
  42:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
  43:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
  44:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //#################################################################################################
  45:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // UART CONFIGURAÇÔES
  46:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //#################################################################################################
  47:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //#################################################################################################
  48:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
  49:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
  50:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Descrição: 	Incializa e configura o modo de trabalho da UART
  51:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Parametros:	baudrate: 
  52:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //					1200, 2400, ... , 57600, 115200 ...
  53:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Retorna:		retorna pdPASS se iniciliazou sem problemas ou retorna código de erro
  54:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
  55:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** int uart1_Init(u32 baudrate) {
  27              		.loc 1 55 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 24
  35              		.cfi_offset 3, -24
  36              		.cfi_offset 4, -20
  37              		.cfi_offset 5, -16
  38              		.cfi_offset 6, -12
  39              		.cfi_offset 7, -8
  40              		.cfi_offset 14, -4
  56:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	u32 f_div;
  57:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	
  58:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	PCONP |= PCUART1;											// Ligar a uart no controle de potencia. Tem que ser antes da config
  41              		.loc 1 58 0
  42 0002 254B     		ldr	r3, .L2
  59:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	
  60:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	#if defined(arm7tdmi)
  61:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1_PINSEL = (U1_PINSEL & ~U1_PINMASK) | U1_PINS;			// Configura os pinos do uC para a função UAR
  62:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	#if defined(LPC2468)
  63:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   		U1_PINSEL1 = (U1_PINSEL1 & ~U1_PINMASK1) | U1_PINS1;	// Configura os pinos do uC para a função 
  64:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	#endif
  65:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	#endif // arm7tdmi
  66:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
  67:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	#if defined(cortexm3)
  68:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	uart1_ConfigPort();
  69:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	#endif
  70:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
  71:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	#if (UART1_USE_HANDSHAKING == pdON)
  72:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	// Por padrão esses pinos já são GPIO
  73:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	U1_CTS_DIR &= ~U1_CTS; 				// Pino CTS como entrada
  74:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	U1_RTS_DIR |= U1_RTS; 				// Pino RTS como saída
  75:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	uart1_RTSon(); 						// Sinaliza que posso receber dados
  76:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	#endif
  77:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
  78:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1IER = 0;   	                      						// Desabilita todas as fonte de interrupções da uart
  43              		.loc 1 78 0
  44 0004 254C     		ldr	r4, .L2+4
  58:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	PCONP |= PCUART1;											// Ligar a uart no controle de potencia. Tem que ser antes da config
  45              		.loc 1 58 0
  46 0006 1A68     		ldr	r2, [r3, #0]
  47              		.loc 1 78 0
  48 0008 0026     		movs	r6, #0
  58:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	PCONP |= PCUART1;											// Ligar a uart no controle de potencia. Tem que ser antes da config
  49              		.loc 1 58 0
  50 000a 42F01002 		orr	r2, r2, #16
  51 000e 1A60     		str	r2, [r3, #0]
  68:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	uart1_ConfigPort();
  52              		.loc 1 68 0
  53 0010 234B     		ldr	r3, .L2+8
  79:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1IIR;                                						// Limpa os identificadores de pendencia interrupçõe
  80:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1FCR = (U1FCR_TX_FIFO_RESET | U1FCR_RX_FIFO_RESET);		// Limpa TX e RX FIFOS
  54              		.loc 1 80 0
  55 0012 0627     		movs	r7, #6
  68:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	uart1_ConfigPort();
  56              		.loc 1 68 0
  57 0014 1A68     		ldr	r2, [r3, #0]
  81:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	
  82:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1LCR = U1LCR_DLAB_ENABLE;             						// Seleciona os latches de devisões para ajusta do 
  58              		.loc 1 82 0
  59 0016 8021     		movs	r1, #128
  68:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	uart1_ConfigPort();
  60              		.loc 1 68 0
  61 0018 42F08042 		orr	r2, r2, #1073741824
  62 001c 1A60     		str	r2, [r3, #0]
  63 001e 5A68     		ldr	r2, [r3, #4]
  64 0020 42F00102 		orr	r2, r2, #1
  65 0024 5A60     		str	r2, [r3, #4]
  79:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1IIR;                                						// Limpa os identificadores de pendencia interrupçõe
  66              		.loc 1 79 0
  67 0026 1F4B     		ldr	r3, .L2+12
  78:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1IER = 0;   	                      						// Desabilita todas as fonte de interrupções da uart
  68              		.loc 1 78 0
  69 0028 2660     		str	r6, [r4, #0]
  79:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1IIR;                                						// Limpa os identificadores de pendencia interrupçõe
  70              		.loc 1 79 0
  71 002a 1A68     		ldr	r2, [r3, #0]
  72              		.loc 1 82 0
  73 002c 1E4A     		ldr	r2, .L2+16
  80:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1FCR = (U1FCR_TX_FIFO_RESET | U1FCR_RX_FIFO_RESET);		// Limpa TX e RX FIFOS
  74              		.loc 1 80 0
  75 002e 1F60     		str	r7, [r3, #0]
  76              		.loc 1 82 0
  77 0030 1160     		str	r1, [r2, #0]
  83:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	f_div = ( PCLK / 16 ) / baudrate ;							// Calcular divisor para o baudrate
  78              		.loc 1 83 0
  79 0032 1E49     		ldr	r1, .L2+20
  80 0034 B1FBF0F0 		udiv	r0, r1, r0
  81              	.LVL1:
  84:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1DLL = f_div%256;              							// Ajusta o baudrate byte baixo
  82              		.loc 1 84 0
  83 0038 1D49     		ldr	r1, .L2+24
  84 003a C5B2     		uxtb	r5, r0
  85:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1DLM = f_div/256;       									// Ajusta o baudrate byte alto
  85              		.loc 1 85 0
  86 003c 000A     		lsrs	r0, r0, #8
  87              	.LVL2:
  84:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1DLL = f_div%256;              							// Ajusta o baudrate byte baixo
  88              		.loc 1 84 0
  89 003e 0D60     		str	r5, [r1, #0]
  90              		.loc 1 85 0
  91 0040 2060     		str	r0, [r4, #0]
  86:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1LCR = (UART1_MODE & ~U1LCR_DLAB_ENABLE);					// Configura o modo de trabalho da uart e desativ
  87:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	
  88:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1FCR = UART1_FIFOMODE;										// Configura o modo de trabalho da FIFO
  92              		.loc 1 88 0
  93 0042 0125     		movs	r5, #1
  86:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1LCR = (UART1_MODE & ~U1LCR_DLAB_ENABLE);					// Configura o modo de trabalho da uart e desativ
  94              		.loc 1 86 0
  95 0044 0320     		movs	r0, #3
  96 0046 1060     		str	r0, [r2, #0]
  97              		.loc 1 88 0
  98 0048 1D60     		str	r5, [r3, #0]
  89:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
  90:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	U1RBR;                                						// Limpa o registrador de recepçao de dados
  99              		.loc 1 90 0
 100 004a 0A68     		ldr	r2, [r1, #0]
  91:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1LSR;                                						// Limpa o registrador de estado de linha
 101              		.loc 1 91 0
 102 004c 194A     		ldr	r2, .L2+28
  92:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	U1FCR = U1FCR_RX_FIFO_RESET;								// Limpa a FIFO de recepção
  93:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1FCR = U1FCR_TX_FIFO_RESET;          						// Limpa a FIFO de transmissão
  94:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
  95:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	#if defined(arm7tdmi)
  96:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	if (!irq_Install(VIC_UART1, uart1_ISR, UART1_PRIO_LEVEL))
  97:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		return errIRQ_INSTALL;
  98:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	#endif
  99:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 100:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	#if defined (cortexm3)
 101:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	nvic_enableIRQ(VIC_UART1);
 103              		.loc 1 101 0
 104 004e 3846     		mov	r0, r7
  91:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1LSR;                                						// Limpa o registrador de estado de linha
 105              		.loc 1 91 0
 106 0050 1268     		ldr	r2, [r2, #0]
  92:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	U1FCR = U1FCR_RX_FIFO_RESET;								// Limpa a FIFO de recepção
 107              		.loc 1 92 0
 108 0052 0222     		movs	r2, #2
 109 0054 1A60     		str	r2, [r3, #0]
  93:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1FCR = U1FCR_TX_FIFO_RESET;          						// Limpa a FIFO de transmissão
 110              		.loc 1 93 0
 111 0056 0422     		movs	r2, #4
 112 0058 1A60     		str	r2, [r3, #0]
 113              		.loc 1 101 0
 114 005a FFF7FEFF 		bl	nvic_enableIRQ
 115              	.LVL3:
 102:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	nvic_setPriority(VIC_UART1, UART1_PRIO_LEVEL);
 116              		.loc 1 102 0
 117 005e 3846     		mov	r0, r7
 118 0060 2946     		mov	r1, r5
 119 0062 FFF7FEFF 		bl	nvic_setPriority
 120              	.LVL4:
 103:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	#endif
 104:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 105:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	// INICIALIZO OS BUFFERS DE RECEPÇÃO E TRANSMISSÃO
 106:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	#if (USE_MALLOC == pdON)
 107:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	u1_data_rx = malloc(UART1_RX_BUFFER_SIZE*sizeof(u8));
 108:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	u1_data_tx = malloc(UART1_TX_BUFFER_SIZE*sizeof(u8));
 109:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	#endif
 110:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 111:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	buffer_Init(&u1_buf_rx, u1_data_rx, UART1_RX_BUFFER_SIZE);
 121              		.loc 1 111 0
 122 0066 1448     		ldr	r0, .L2+32
 123 0068 1449     		ldr	r1, .L2+36
 124 006a 4FF49672 		mov	r2, #300
 125 006e FFF7FEFF 		bl	buffer_Init
 126              	.LVL5:
 112:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	buffer_Init(&u1_buf_tx, u1_data_tx, UART1_TX_BUFFER_SIZE);
 127              		.loc 1 112 0
 128 0072 1348     		ldr	r0, .L2+40
 129 0074 1349     		ldr	r1, .L2+44
 130 0076 4FF49672 		mov	r2, #300
 131 007a FFF7FEFF 		bl	buffer_Init
 132              	.LVL6:
 113:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		
 114:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	u1_overflow_rx = 0; 										// Limpa overflow do buffer de recepção
 133              		.loc 1 114 0
 134 007e 124B     		ldr	r3, .L2+48
 115:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	u1_tx_running = pdFALSE;
 116:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		
 117:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	U1IER |= U1IER_ERBFI;										// Habilita interrupção de dados prontos na recepção e CTI (SIMULAD
 118:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	U1IER &= ~U1IER_ETBEI;               						// Desabilita a interrupção de buffer vazio de transmis
 119:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	
 120:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	return pdPASS;
 121:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** }
 135              		.loc 1 121 0
 136 0080 2846     		mov	r0, r5
 114:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	u1_overflow_rx = 0; 										// Limpa overflow do buffer de recepção
 137              		.loc 1 114 0
 138 0082 1E80     		strh	r6, [r3, #0]	@ movhi
 115:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	u1_tx_running = pdFALSE;
 139              		.loc 1 115 0
 140 0084 114B     		ldr	r3, .L2+52
 141 0086 1E70     		strb	r6, [r3, #0]
 117:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	U1IER |= U1IER_ERBFI;										// Habilita interrupção de dados prontos na recepção e CTI (SIMULAD
 142              		.loc 1 117 0
 143 0088 2368     		ldr	r3, [r4, #0]
 144 008a 2B43     		orrs	r3, r3, r5
 145 008c 2360     		str	r3, [r4, #0]
 118:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	U1IER &= ~U1IER_ETBEI;               						// Desabilita a interrupção de buffer vazio de transmis
 146              		.loc 1 118 0
 147 008e 2368     		ldr	r3, [r4, #0]
 148 0090 23F00203 		bic	r3, r3, #2
 149 0094 2360     		str	r3, [r4, #0]
 150              		.loc 1 121 0
 151 0096 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 152              	.L3:
 153              		.align	2
 154              	.L2:
 155 0098 C4C00F40 		.word	1074774212
 156 009c 04000140 		.word	1073807364
 157 00a0 00C00240 		.word	1073922048
 158 00a4 08000140 		.word	1073807368
 159 00a8 0C000140 		.word	1073807372
 160 00ac 84D71700 		.word	1562500
 161 00b0 00000140 		.word	1073807360
 162 00b4 14000140 		.word	1073807380
 163 00b8 00000000 		.word	.LANCHOR0
 164 00bc 00000000 		.word	.LANCHOR1
 165 00c0 00000000 		.word	.LANCHOR2
 166 00c4 00000000 		.word	.LANCHOR3
 167 00c8 00000000 		.word	.LANCHOR4
 168 00cc 00000000 		.word	.LANCHOR5
 169              		.cfi_endproc
 170              	.LFE0:
 172              		.section	.text.uart1_GetChar,"ax",%progbits
 173              		.align	1
 174              		.global	uart1_GetChar
 175              		.thumb
 176              		.thumb_func
 178              	uart1_GetChar:
 179              	.LFB1:
 122:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 123:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //#################################################################################################
 124:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // UART RECEPÇÂO
 125:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //#################################################################################################
 126:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //#################################################################################################
 127:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 128:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 129:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Descrição:	Captura o próximo byte recebido na UART
 130:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Parametros: 	Ponteiro para da variavel char para o retorno do byte recebido
 131:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Retorna:		pdPASS indicando que existe caractere recebido ou o código do erro
 132:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 133:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** int uart1_GetChar(u8 *ch) {
 180              		.loc 1 133 0
 181              		.cfi_startproc
 182              		@ args = 0, pretend = 0, frame = 0
 183              		@ frame_needed = 0, uses_anonymous_args = 0
 184              	.LVL7:
 134:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	int ret;
 135:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 136:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	if ( u1_buf_rx.size == 0 )								// Checa se o buffer de recepção ainda não foi criado
 185              		.loc 1 136 0
 186 0000 0F4B     		ldr	r3, .L8
 133:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** int uart1_GetChar(u8 *ch) {
 187              		.loc 1 133 0
 188 0002 10B5     		push	{r4, lr}
 189              	.LCFI1:
 190              		.cfi_def_cfa_offset 8
 191              		.cfi_offset 4, -8
 192              		.cfi_offset 14, -4
 193              		.loc 1 136 0
 194 0004 9A88     		ldrh	r2, [r3, #4]
 133:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** int uart1_GetChar(u8 *ch) {
 195              		.loc 1 133 0
 196 0006 0446     		mov	r4, r0
 197              		.loc 1 136 0
 198 0008 92B2     		uxth	r2, r2
 199 000a 9AB1     		cbz	r2, .L6
 137:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****    		return errBUFFER_NO_EXIST;            				// Retorna indicando erro
 138:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 139:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	if ( u1_buf_rx.datalength ) {							// Checo de o buffer de recepção contêm dados recebidos pela U
 200              		.loc 1 139 0
 201 000c DB88     		ldrh	r3, [r3, #6]
 202 000e 9BB2     		uxth	r3, r3
 203 0010 9BB1     		cbz	r3, .L7
 140:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		U1IER &= ~U1IER_ERBFI;								// Desabilita interrupção de dados prontos na recepção e CTI (SIMUL
 204              		.loc 1 140 0
 205 0012 0C4B     		ldr	r3, .L8+4
 206 0014 1A68     		ldr	r2, [r3, #0]
 207 0016 22F00102 		bic	r2, r2, #1
 208 001a 1A60     		str	r2, [r3, #0]
 141:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		nop();
 209              		.loc 1 141 0
 210              	@ 141 "uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c" 1
 211 001c 00BF     		nop
 212              	@ 0 "" 2
 142:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		*ch = buffer_GetFromFront(&u1_buf_rx);				// Captura os dados do inicio do buffer
 213              		.loc 1 142 0
 214              		.thumb
 215 001e 0848     		ldr	r0, .L8
 216              	.LVL8:
 217 0020 FFF7FEFF 		bl	buffer_GetFromFront
 218              	.LVL9:
 143:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		U1IER |= U1IER_ERBFI;								// Habilita interrupção de dados prontos na recepção e CTI (SIMULADO
 219              		.loc 1 143 0
 220 0024 074B     		ldr	r3, .L8+4
 142:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		*ch = buffer_GetFromFront(&u1_buf_rx);				// Captura os dados do inicio do buffer
 221              		.loc 1 142 0
 222 0026 2070     		strb	r0, [r4, #0]
 223              		.loc 1 143 0
 224 0028 1A68     		ldr	r2, [r3, #0]
 144:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		ret = pdPASS;
 225              		.loc 1 144 0
 226 002a 0120     		movs	r0, #1
 143:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		U1IER |= U1IER_ERBFI;								// Habilita interrupção de dados prontos na recepção e CTI (SIMULADO
 227              		.loc 1 143 0
 228 002c 42F00102 		orr	r2, r2, #1
 229 0030 1A60     		str	r2, [r3, #0]
 230              	.LVL10:
 231 0032 10BD     		pop	{r4, pc}
 232              	.LVL11:
 233              	.L6:
 137:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****    		return errBUFFER_NO_EXIST;            				// Retorna indicando erro
 234              		.loc 1 137 0
 235 0034 6FF00B00 		mvn	r0, #11
 236              	.LVL12:
 237 0038 10BD     		pop	{r4, pc}
 238              	.LVL13:
 239              	.L7:
 145:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	} else
 146:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		ret = errBUFFER_EMPTY;
 240              		.loc 1 146 0
 241 003a 6FF00A00 		mvn	r0, #10
 242              	.LVL14:
 147:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 148:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	return ret;
 149:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** }
 243              		.loc 1 149 0
 244 003e 10BD     		pop	{r4, pc}
 245              	.L9:
 246              		.align	2
 247              	.L8:
 248 0040 00000000 		.word	.LANCHOR0
 249 0044 04000140 		.word	1073807364
 250              		.cfi_endproc
 251              	.LFE1:
 253              		.section	.text.uart1_ClearBufferRx,"ax",%progbits
 254              		.align	1
 255              		.global	uart1_ClearBufferRx
 256              		.thumb
 257              		.thumb_func
 259              	uart1_ClearBufferRx:
 260              	.LFB2:
 150:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 151:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 152:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 153:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Descrição: 	Limpa o buffer e FIFO de recepção
 154:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Parametros:	Nenhum
 155:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Retorna:		Nada
 156:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 157:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** void uart1_ClearBufferRx(void) {
 261              		.loc 1 157 0
 262              		.cfi_startproc
 263              		@ args = 0, pretend = 0, frame = 0
 264              		@ frame_needed = 0, uses_anonymous_args = 0
 265 0000 08B5     		push	{r3, lr}
 266              	.LCFI2:
 267              		.cfi_def_cfa_offset 8
 268              		.cfi_offset 3, -8
 269              		.cfi_offset 14, -4
 158:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	U1IER &= ~U1IER_ERBFI;				// Desabilita interrupção de dados prontos na recepção e CTI (SIMULADOR 
 270              		.loc 1 158 0
 271 0002 0A4B     		ldr	r3, .L11
 272 0004 1A68     		ldr	r2, [r3, #0]
 273 0006 22F00102 		bic	r2, r2, #1
 274 000a 1A60     		str	r2, [r3, #0]
 159:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	nop();
 275              		.loc 1 159 0
 276              	@ 159 "uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c" 1
 277 000c 00BF     		nop
 278              	@ 0 "" 2
 160:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	u1_overflow_rx = 0; 				// Limpa overflow do buffer de recepção
 279              		.loc 1 160 0
 280              		.thumb
 281 000e 084B     		ldr	r3, .L11+4
 282 0010 0022     		movs	r2, #0
 283 0012 1A80     		strh	r2, [r3, #0]	@ movhi
 161:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	U1FCR = U1FCR_RX_FIFO_RESET;		// Limpa RX FIFO
 284              		.loc 1 161 0
 285 0014 074B     		ldr	r3, .L11+8
 286 0016 0222     		movs	r2, #2
 287 0018 1A60     		str	r2, [r3, #0]
 162:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	buffer_Clear(&u1_buf_rx);			// Limpa o buffer de recepção
 288              		.loc 1 162 0
 289 001a 0748     		ldr	r0, .L11+12
 290 001c FFF7FEFF 		bl	buffer_Clear
 291              	.LVL15:
 163:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	U1IER |= U1IER_ERBFI;				// Habilita interrupção de dados prontos na recepção e CTI (SIMULADOR PRO
 292              		.loc 1 163 0
 293 0020 024B     		ldr	r3, .L11
 294 0022 1A68     		ldr	r2, [r3, #0]
 295 0024 42F00102 		orr	r2, r2, #1
 296 0028 1A60     		str	r2, [r3, #0]
 297 002a 08BD     		pop	{r3, pc}
 298              	.L12:
 299              		.align	2
 300              	.L11:
 301 002c 04000140 		.word	1073807364
 302 0030 00000000 		.word	.LANCHOR4
 303 0034 08000140 		.word	1073807368
 304 0038 00000000 		.word	.LANCHOR0
 305              		.cfi_endproc
 306              	.LFE2:
 308              		.section	.text.uart1_CountRxOverflow,"ax",%progbits
 309              		.align	1
 310              		.global	uart1_CountRxOverflow
 311              		.thumb
 312              		.thumb_func
 314              	uart1_CountRxOverflow:
 315              	.LFB3:
 164:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** }
 165:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 166:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 167:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Descrição: 	Retorna a quantidade de bytes do estouro do buffer de recepção
 168:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Parametros:	Nenhum
 169:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Retorna:		Nada
 170:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 171:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** u32 uart1_CountRxOverflow (void) {
 316              		.loc 1 171 0
 317              		.cfi_startproc
 318              		@ args = 0, pretend = 0, frame = 0
 319              		@ frame_needed = 0, uses_anonymous_args = 0
 320              		@ link register save eliminated.
 172:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	u32 count = u1_overflow_rx;
 321              		.loc 1 172 0
 322 0000 024B     		ldr	r3, .L14
 173:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	u1_overflow_rx = 0;
 323              		.loc 1 173 0
 324 0002 0022     		movs	r2, #0
 172:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	u32 count = u1_overflow_rx;
 325              		.loc 1 172 0
 326 0004 1888     		ldrh	r0, [r3, #0]
 327              	.LVL16:
 328              		.loc 1 173 0
 329 0006 1A80     		strh	r2, [r3, #0]	@ movhi
 174:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	return count;
 175:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** }
 330              		.loc 1 175 0
 331 0008 80B2     		uxth	r0, r0
 332              	.LVL17:
 333 000a 7047     		bx	lr
 334              	.L15:
 335              		.align	2
 336              	.L14:
 337 000c 00000000 		.word	.LANCHOR4
 338              		.cfi_endproc
 339              	.LFE3:
 341              		.section	.text.uart1_BufferRxIsEmpty,"ax",%progbits
 342              		.align	1
 343              		.global	uart1_BufferRxIsEmpty
 344              		.thumb
 345              		.thumb_func
 347              	uart1_BufferRxIsEmpty:
 348              	.LFB4:
 176:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 177:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 178:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Descrição: 	Checa se buffer de recepção está vazio
 179:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Parametros:	Nenhum
 180:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Retorna:		pdTRUE se o buffer estiver vazio
 181:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //				pdFALSE se o buffer contiver dados recebidos
 182:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 183:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** int uart1_BufferRxIsEmpty(void) {
 349              		.loc 1 183 0
 350              		.cfi_startproc
 351              		@ args = 0, pretend = 0, frame = 0
 352              		@ frame_needed = 0, uses_anonymous_args = 0
 353              		@ link register save eliminated.
 184:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	if (u1_buf_rx.datalength == 0)
 354              		.loc 1 184 0
 355 0000 034B     		ldr	r3, .L17
 356 0002 D888     		ldrh	r0, [r3, #6]
 357 0004 80B2     		uxth	r0, r0
 185:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 			return pdTRUE;
 186:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	else	return pdFALSE;
 187:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** }
 358              		.loc 1 187 0
 359 0006 D0F10100 		rsbs	r0, r0, #1
 360 000a 38BF     		it	cc
 361 000c 0020     		movcc	r0, #0
 362 000e 7047     		bx	lr
 363              	.L18:
 364              		.align	2
 365              	.L17:
 366 0010 00000000 		.word	.LANCHOR0
 367              		.cfi_endproc
 368              	.LFE4:
 370              		.section	.text.uart1_BufferQtdRx,"ax",%progbits
 371              		.align	1
 372              		.global	uart1_BufferQtdRx
 373              		.thumb
 374              		.thumb_func
 376              	uart1_BufferQtdRx:
 377              	.LFB5:
 188:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 189:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 190:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Descrição: 	Retorna com a quantidade de bytes recebidos no buffer de recepção
 191:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Parametros:	Nenhum
 192:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Retorna:		Retorna com a quantidade de bytes recebidos no buffer de recepção
 193:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 194:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** int uart1_BufferQtdRx(void) {
 378              		.loc 1 194 0
 379              		.cfi_startproc
 380              		@ args = 0, pretend = 0, frame = 0
 381              		@ frame_needed = 0, uses_anonymous_args = 0
 382              		@ link register save eliminated.
 195:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	return u1_buf_rx.datalength;
 383              		.loc 1 195 0
 384 0000 014B     		ldr	r3, .L20
 385 0002 D888     		ldrh	r0, [r3, #6]
 196:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** }
 386              		.loc 1 196 0
 387 0004 80B2     		uxth	r0, r0
 388 0006 7047     		bx	lr
 389              	.L21:
 390              		.align	2
 391              	.L20:
 392 0008 00000000 		.word	.LANCHOR0
 393              		.cfi_endproc
 394              	.LFE5:
 396              		.section	.text.uart1_GetBufferRx,"ax",%progbits
 397              		.align	1
 398              		.global	uart1_GetBufferRx
 399              		.thumb
 400              		.thumb_func
 402              	uart1_GetBufferRx:
 403              	.LFB6:
 197:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 198:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 199:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Descrição: 	Retorna o ponteiro da estrutura do buffer de recepção
 200:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Parametros:	Nenhum
 201:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Retorna:		Retorna o ponteiro da estrutura do buffer de recepção
 202:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 203:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** buffer_t *uart1_GetBufferRx(void) {
 404              		.loc 1 203 0
 405              		.cfi_startproc
 406              		@ args = 0, pretend = 0, frame = 0
 407              		@ frame_needed = 0, uses_anonymous_args = 0
 408              		@ link register save eliminated.
 204:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	return &u1_buf_rx;
 205:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** }
 409              		.loc 1 205 0
 410 0000 0048     		ldr	r0, .L23
 411 0002 7047     		bx	lr
 412              	.L24:
 413              		.align	2
 414              	.L23:
 415 0004 00000000 		.word	.LANCHOR0
 416              		.cfi_endproc
 417              	.LFE6:
 419              		.section	.text.uart1_PutChar,"ax",%progbits
 420              		.align	1
 421              		.global	uart1_PutChar
 422              		.thumb
 423              		.thumb_func
 425              	uart1_PutChar:
 426              	.LFB7:
 206:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 207:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //#################################################################################################
 208:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // UART TRANSMISSAO
 209:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //#################################################################################################
 210:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //#################################################################################################
 211:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 212:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 213:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Descrição:	Coloca um caractere na fila de transmissão
 214:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Parametros: 	Caractere a ser transmitindo
 215:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Retorna:		Retorna pdPASS ou o código de erro
 216:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 217:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** int uart1_PutChar(n16 ch) {
 427              		.loc 1 217 0
 428              		.cfi_startproc
 429              		@ args = 0, pretend = 0, frame = 0
 430              		@ frame_needed = 0, uses_anonymous_args = 0
 431              	.LVL18:
 218:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	int sts;
 219:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 220:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	if ( u1_buf_tx.size == 0 )												// Checa se o buffer de transmissão ainda não foi criado
 432              		.loc 1 220 0
 433 0000 154B     		ldr	r3, .L35
 217:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** int uart1_PutChar(n16 ch) {
 434              		.loc 1 217 0
 435 0002 70B5     		push	{r4, r5, r6, lr}
 436              	.LCFI3:
 437              		.cfi_def_cfa_offset 16
 438              		.cfi_offset 4, -16
 439              		.cfi_offset 5, -12
 440              		.cfi_offset 6, -8
 441              		.cfi_offset 14, -4
 442              		.loc 1 220 0
 443 0004 9B88     		ldrh	r3, [r3, #4]
 444 0006 9BB2     		uxth	r3, r3
 445 0008 03B3     		cbz	r3, .L28
 221:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****    		return errBUFFER_NO_EXIST;                          				// Retorna indicando erro
 222:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 223:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	// É obrigatório incluirmos o char no buffer, mesmo que vamos retirá-lo logo em seguida caso u3_tx
 224:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	//	Se não for dessa forma o e usar U3THR = ch haverá erro de sincronismo entre os dados chegas e d
 225:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	// Isto porque o manipulador de interrupção (uart3_ISR) pode atender a mais de uma interrupção sim
 226:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 227:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	do {
 228:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		U1IER &= ~U1IER_ETBEI;                 								// Desativa a interrupção de transmissão
 446              		.loc 1 228 0
 447 000a 144C     		ldr	r4, .L35+4
 229:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		nop();
 230:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		sts = buffer_AddToEnd(&u1_buf_tx, ch);
 448              		.loc 1 230 0
 449 000c C6B2     		uxtb	r6, r0
 450              	.LVL19:
 451              	.L32:
 228:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		U1IER &= ~U1IER_ETBEI;                 								// Desativa a interrupção de transmissão
 452              		.loc 1 228 0
 453 000e 2368     		ldr	r3, [r4, #0]
 454 0010 23F00203 		bic	r3, r3, #2
 455 0014 2360     		str	r3, [r4, #0]
 229:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		nop();
 456              		.loc 1 229 0
 457              	@ 229 "uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c" 1
 458 0016 00BF     		nop
 459              	@ 0 "" 2
 460              		.loc 1 230 0
 461              		.thumb
 462 0018 0F48     		ldr	r0, .L35
 463 001a 3146     		mov	r1, r6
 464 001c FFF7FEFF 		bl	buffer_AddToEnd
 465              	.LVL20:
 231:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		U1IER |= U1IER_ETBEI;                  								// Habilita a interrupção de transmissão
 466              		.loc 1 231 0
 467 0020 2368     		ldr	r3, [r4, #0]
 232:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 233:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		CRITICAL_WAIT;														// Caso exista algum OS, pode trocar de contexto
 234:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	} while (sts == errBUFFER_FULL);
 468              		.loc 1 234 0
 469 0022 0A30     		adds	r0, r0, #10
 470              	.LVL21:
 231:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 		U1IER |= U1IER_ETBEI;                  								// Habilita a interrupção de transmissão
 471              		.loc 1 231 0
 472 0024 43F00203 		orr	r3, r3, #2
 473 0028 0C4D     		ldr	r5, .L35+4
 474 002a 2360     		str	r3, [r4, #0]
 475              		.loc 1 234 0
 476 002c EFD0     		beq	.L32
 235:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 236:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	if (!u1_tx_running) {													// Checa se existe dado sendo transmitido
 477              		.loc 1 236 0
 478 002e 0C4C     		ldr	r4, .L35+8
 479 0030 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 480 0032 73B9     		cbnz	r3, .L29
 481              	.LBB4:
 482              	.LBB5:
 237:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   		U1THR = buffer_GetFromFront(&u1_buf_tx);							// Atribui o dado do buffer ao registrador de tr
 483              		.loc 1 237 0
 484 0034 0848     		ldr	r0, .L35
 485              	.LVL22:
 486 0036 FFF7FEFF 		bl	buffer_GetFromFront
 487              	.LVL23:
 488 003a 0A4B     		ldr	r3, .L35+12
 489 003c 1860     		str	r0, [r3, #0]
 238:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   		u1_tx_running = pdTRUE;												// Sinaliza que existe dado sendo trasnmitido
 490              		.loc 1 238 0
 491 003e 0120     		movs	r0, #1
 492 0040 2070     		strb	r0, [r4, #0]
 239:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   		U1IER |= U1IER_ETBEI;                  								// Habilita a interrupção de transmissão
 493              		.loc 1 239 0
 494 0042 2B68     		ldr	r3, [r5, #0]
 495 0044 43F00203 		orr	r3, r3, #2
 496 0048 2B60     		str	r3, [r5, #0]
 497 004a 70BD     		pop	{r4, r5, r6, pc}
 498              	.LVL24:
 499              	.L28:
 500              	.LBE5:
 501              	.LBE4:
 221:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****    		return errBUFFER_NO_EXIST;                          				// Retorna indicando erro
 502              		.loc 1 221 0
 503 004c 6FF00B00 		mvn	r0, #11
 504              	.LVL25:
 505 0050 70BD     		pop	{r4, r5, r6, pc}
 506              	.LVL26:
 507              	.L29:
 240:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****    	}
 241:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 242:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	return pdPASS;
 508              		.loc 1 242 0
 509 0052 0120     		movs	r0, #1
 510              	.LVL27:
 243:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** }
 511              		.loc 1 243 0
 512 0054 70BD     		pop	{r4, r5, r6, pc}
 513              	.L36:
 514 0056 00BF     		.align	2
 515              	.L35:
 516 0058 00000000 		.word	.LANCHOR2
 517 005c 04000140 		.word	1073807364
 518 0060 00000000 		.word	.LANCHOR5
 519 0064 00000140 		.word	1073807360
 520              		.cfi_endproc
 521              	.LFE7:
 523              		.section	.text.uart1_BasicPutChar,"ax",%progbits
 524              		.align	1
 525              		.global	uart1_BasicPutChar
 526              		.thumb
 527              		.thumb_func
 529              	uart1_BasicPutChar:
 530              	.LFB8:
 244:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 245:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 246:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Descrição:	Coloca um caractere na fila de transmissão. FUNÇÃO UTIL PARA DEBUG ONDE NÃO PRECISA I
 247:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Parametros: 	Caractere a ser transmitindo
 248:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Retorna:		Retorna pdPASS ou o código de erro
 249:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 250:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** int uart1_BasicPutChar(n16 ch) {
 531              		.loc 1 250 0
 532              		.cfi_startproc
 533              		@ args = 0, pretend = 0, frame = 0
 534              		@ frame_needed = 0, uses_anonymous_args = 0
 535              		@ link register save eliminated.
 536              	.LVL28:
 251:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	while (!(U1LSR & U1LSR_THRE)) 								// Espero até que o buffer TX fique vazio
 537              		.loc 1 251 0
 538 0000 044A     		ldr	r2, .L43
 539              	.L38:
 540              		.loc 1 251 0 is_stmt 0 discriminator 1
 541 0002 1368     		ldr	r3, [r2, #0]
 542 0004 9B06     		lsls	r3, r3, #26
 543 0006 FCD5     		bpl	.L38
 252:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   		CRITICAL_WAIT;        									// Caso exista algum OS, pode trocar de contexto
 253:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1THR = (u8)ch;												// Atualiza o registrador de TX uart com o dado
 544              		.loc 1 253 0 is_stmt 1
 545 0008 034B     		ldr	r3, .L43+4
 546 000a C0B2     		uxtb	r0, r0
 547              	.LVL29:
 548 000c 1860     		str	r0, [r3, #0]
 254:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	return pdPASS;
 255:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** }
 549              		.loc 1 255 0
 550 000e 0120     		movs	r0, #1
 551 0010 7047     		bx	lr
 552              	.L44:
 553 0012 00BF     		.align	2
 554              	.L43:
 555 0014 14000140 		.word	1073807380
 556 0018 00000140 		.word	1073807360
 557              		.cfi_endproc
 558              	.LFE8:
 560              		.section	.text.uart1_SpaceTx,"ax",%progbits
 561              		.align	1
 562              		.global	uart1_SpaceTx
 563              		.thumb
 564              		.thumb_func
 566              	uart1_SpaceTx:
 567              	.LFB9:
 256:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 257:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 258:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Descrição:	Captura o espaço disponivel para transmissão
 259:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Parametros: 	Nenhum
 260:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Retorna:		O tamanho em bytes do espaço disponivel para transmissão
 261:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 262:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** u16 uart1_SpaceTx(void) {
 568              		.loc 1 262 0
 569              		.cfi_startproc
 570              		@ args = 0, pretend = 0, frame = 0
 571              		@ frame_needed = 0, uses_anonymous_args = 0
 572              		@ link register save eliminated.
 263:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	u16 qtd;
 264:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	
 265:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	U1IER &= ~U1IER_ETBEI;                 								// Desativa a interrupção de transmissão
 573              		.loc 1 265 0
 574 0000 084B     		ldr	r3, .L46
 575 0002 1A68     		ldr	r2, [r3, #0]
 576 0004 22F00202 		bic	r2, r2, #2
 577 0008 1A60     		str	r2, [r3, #0]
 266:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	nop();
 578              		.loc 1 266 0
 579              	@ 266 "uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c" 1
 580 000a 00BF     		nop
 581              	@ 0 "" 2
 267:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	qtd = (u16)(u1_buf_tx.size - u1_buf_tx.datalength);					// Retorna com o espaço disponivel
 582              		.loc 1 267 0
 583              		.thumb
 584 000c 064B     		ldr	r3, .L46+4
 585 000e 9888     		ldrh	r0, [r3, #4]
 586 0010 DA88     		ldrh	r2, [r3, #6]
 587              	.LVL30:
 268:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	U1IER |= U1IER_ETBEI;                  								// Habilita a interrupção de transmissão
 588              		.loc 1 268 0
 589 0012 044B     		ldr	r3, .L46
 267:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	qtd = (u16)(u1_buf_tx.size - u1_buf_tx.datalength);					// Retorna com o espaço disponivel
 590              		.loc 1 267 0
 591 0014 801A     		subs	r0, r0, r2
 592              	.LVL31:
 593              		.loc 1 268 0
 594 0016 1968     		ldr	r1, [r3, #0]
 269:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	return qtd;
 270:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** }
 595              		.loc 1 270 0
 596 0018 80B2     		uxth	r0, r0
 268:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	U1IER |= U1IER_ETBEI;                  								// Habilita a interrupção de transmissão
 597              		.loc 1 268 0
 598 001a 41F00201 		orr	r1, r1, #2
 599 001e 1960     		str	r1, [r3, #0]
 600              		.loc 1 270 0
 601 0020 7047     		bx	lr
 602              	.L47:
 603 0022 00BF     		.align	2
 604              	.L46:
 605 0024 04000140 		.word	1073807364
 606 0028 00000000 		.word	.LANCHOR2
 607              		.cfi_endproc
 608              	.LFE9:
 610              		.section	.text.uart1_FlushTx,"ax",%progbits
 611              		.align	1
 612              		.global	uart1_FlushTx
 613              		.thumb
 614              		.thumb_func
 616              	uart1_FlushTx:
 617              	.LFB10:
 271:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 272:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 273:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Descrição:	Remove todos os dados da fila de transmissão
 274:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Parametros: 	Nenhum
 275:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Retorna:		Nada
 276:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 277:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** void uart1_FlushTx(void) {
 618              		.loc 1 277 0
 619              		.cfi_startproc
 620              		@ args = 0, pretend = 0, frame = 0
 621              		@ frame_needed = 0, uses_anonymous_args = 0
 622              		@ link register save eliminated.
 278:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	U1IER &= ~U1IER_ETBEI;                					// Desabilita a interrupção de transmissão
 623              		.loc 1 278 0
 624 0000 054B     		ldr	r3, .L49
 625 0002 1A68     		ldr	r2, [r3, #0]
 626 0004 22F00202 		bic	r2, r2, #2
 627 0008 1A60     		str	r2, [r3, #0]
 279:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	nop();
 628              		.loc 1 279 0
 629              	@ 279 "uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c" 1
 630 000a 00BF     		nop
 631              	@ 0 "" 2
 280:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1FCR = U1FCR_TX_FIFO_RESET;          					// Limpa a FIFO de transmissão
 281:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	buffer_Clear(&u1_buf_tx);								// Limpa os indeces do buffer TX da UART
 632              		.loc 1 281 0
 633              		.thumb
 634 000c 0348     		ldr	r0, .L49+4
 280:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	U1FCR = U1FCR_TX_FIFO_RESET;          					// Limpa a FIFO de transmissão
 635              		.loc 1 280 0
 636 000e 0422     		movs	r2, #4
 637 0010 5A60     		str	r2, [r3, #4]
 282:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** }
 638              		.loc 1 282 0
 281:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	buffer_Clear(&u1_buf_tx);								// Limpa os indeces do buffer TX da UART
 639              		.loc 1 281 0
 640 0012 FFF7FEBF 		b	buffer_Clear
 641              	.LVL32:
 642              	.L50:
 643 0016 00BF     		.align	2
 644              	.L49:
 645 0018 04000140 		.word	1073807364
 646 001c 00000000 		.word	.LANCHOR2
 647              		.cfi_endproc
 648              	.LFE10:
 650              		.section	.text.uart1_EmptyTx,"ax",%progbits
 651              		.align	1
 652              		.global	uart1_EmptyTx
 653              		.thumb
 654              		.thumb_func
 656              	uart1_EmptyTx:
 657              	.LFB11:
 283:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 284:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 285:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Descrição:	Retorna o status do registrador de transmissão de dados
 286:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Parametros: 	Nenhum
 287:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Retorna:		pdFALSE = Se o registradores U0THR ou U0TSR não estão vazios
 288:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //				pdTRUE = Se o registradores U0THR ou U0TSR estão vazios
 289:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 290:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** int uart1_EmptyTx(void) {
 658              		.loc 1 290 0
 659              		.cfi_startproc
 660              		@ args = 0, pretend = 0, frame = 0
 661              		@ frame_needed = 0, uses_anonymous_args = 0
 662              		@ link register save eliminated.
 291:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	if ((U1LSR & (U1LSR_THRE | U1LSR_TEMT)) == (U1LSR_THRE | U1LSR_TEMT))
 663              		.loc 1 291 0
 664 0000 044B     		ldr	r3, .L52
 665 0002 1868     		ldr	r0, [r3, #0]
 666 0004 00F06000 		and	r0, r0, #96
 292:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   			return pdTRUE;
 293:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	else	return pdFALSE;
 294:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** }
 667              		.loc 1 294 0
 668 0008 B0F16002 		subs	r2, r0, #96
 669 000c 5042     		rsbs	r0, r2, #0
 670 000e 5041     		adcs	r0, r0, r2
 671 0010 7047     		bx	lr
 672              	.L53:
 673 0012 00BF     		.align	2
 674              	.L52:
 675 0014 14000140 		.word	1073807380
 676              		.cfi_endproc
 677              	.LFE11:
 679              		.section	.text.uart1_WriteTx,"ax",%progbits
 680              		.align	1
 681              		.global	uart1_WriteTx
 682              		.thumb
 683              		.thumb_func
 685              	uart1_WriteTx:
 686              	.LFB12:
 295:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 296:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** #if !defined(FREE_RTOS)
 297:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 298:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Descrição:	Adiociona N caracteres no buffer de transmissão
 299:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Parametros: 	Ponteiro do buffer 
 300:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //				Quantidade de caracteres as serem transmitidos
 301:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Retorna:		pdPASS = Transmitido com sucesso ou o código do erro
 302:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 303:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** int uart1_WriteTx(u8 *buffer, u16 count) {
 687              		.loc 1 303 0
 688              		.cfi_startproc
 689              		@ args = 0, pretend = 0, frame = 0
 690              		@ frame_needed = 0, uses_anonymous_args = 0
 691              	.LVL33:
 692 0000 38B5     		push	{r3, r4, r5, lr}
 693              	.LCFI4:
 694              		.cfi_def_cfa_offset 16
 695              		.cfi_offset 3, -16
 696              		.cfi_offset 4, -12
 697              		.cfi_offset 5, -8
 698              		.cfi_offset 14, -4
 699              		.loc 1 303 0
 700 0002 0C46     		mov	r4, r1
 701 0004 0546     		mov	r5, r0
 304:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	if (count > uart1_SpaceTx())									// Checa se exste espaço suficiente no buffer de TX de espaço
 702              		.loc 1 304 0
 703 0006 FFF7FEFF 		bl	uart1_SpaceTx
 704              	.LVL34:
 705 000a 8442     		cmp	r4, r0
 706 000c 04D9     		bls	.L60
 707              	.LVL35:
 708              	.L55:
 305:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****    		return errBUFFER_FULL;										// Retorna cheio
 709              		.loc 1 305 0
 710 000e 6FF00900 		mvn	r0, #9
 711 0012 38BD     		pop	{r3, r4, r5, pc}
 712              	.LVL36:
 713              	.L58:
 306:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	
 307:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	while (count && (uart1_PutChar(*buffer++) >= 0))				// Faça enquanto tem dados a serem transmiti
 308:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****     	count--;
 714              		.loc 1 308 0
 715 0014 013C     		subs	r4, r4, #1
 716              	.LVL37:
 717 0016 A4B2     		uxth	r4, r4
 718              	.LVL38:
 719              	.L60:
 307:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	while (count && (uart1_PutChar(*buffer++) >= 0))				// Faça enquanto tem dados a serem transmiti
 720              		.loc 1 307 0 discriminator 1
 721 0018 34B1     		cbz	r4, .L59
 307:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	while (count && (uart1_PutChar(*buffer++) >= 0))				// Faça enquanto tem dados a serem transmiti
 722              		.loc 1 307 0 is_stmt 0 discriminator 2
 723 001a 15F8010B 		ldrb	r0, [r5], #1	@ zero_extendqisi2
 724              	.LVL39:
 725 001e FFF7FEFF 		bl	uart1_PutChar
 726              	.LVL40:
 727 0022 0028     		cmp	r0, #0
 728 0024 F6DA     		bge	.L58
 729 0026 F2E7     		b	.L55
 730              	.LVL41:
 731              	.L59:
 309:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 310:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	return (count ? errBUFFER_FULL : pdPASS); 						// Se count = 0 retorna 0 (Sucesso) senão retorn
 732              		.loc 1 310 0 is_stmt 1
 733 0028 0120     		movs	r0, #1
 311:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** }
 734              		.loc 1 311 0
 735 002a 38BD     		pop	{r3, r4, r5, pc}
 736              		.cfi_endproc
 737              	.LFE12:
 739              		.section	.text.uart1_PutString,"ax",%progbits
 740              		.align	1
 741              		.global	uart1_PutString
 742              		.thumb
 743              		.thumb_func
 745              	uart1_PutString:
 746              	.LFB13:
 312:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 313:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 314:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Descrição:	Transmite uma string até que encontre o caractere NULO '\0' ou que o buffer estoura
 315:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //				ATENÇÂO: o Compilador já adiciona \0 na string do tipo "xyz" EX: "\r\r\nHello World!\r\r\n" 
 316:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Parametros: 	Ponteiro da string
 317:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // Retorna:		O ponteiro da string. 
 318:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //					Retorna NULO se a string foi completamente transmitindo 
 319:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //					Ou retorna o ponteiro do próximo caractere a ser transmitido
 320:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // OBS: Se a string for maior que o espaço disponivel no buffer de TX pode ocorrer que a string não
 321:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // ------------------------------------------------------------------------------------------------
 322:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** u8 *uart1_PutString(u8 *str) {
 747              		.loc 1 322 0
 748              		.cfi_startproc
 749              		@ args = 0, pretend = 0, frame = 0
 750              		@ frame_needed = 0, uses_anonymous_args = 0
 751              	.LVL42:
 752 0000 38B5     		push	{r3, r4, r5, lr}
 753              	.LCFI5:
 754              		.cfi_def_cfa_offset 16
 755              		.cfi_offset 3, -16
 756              		.cfi_offset 4, -12
 757              		.cfi_offset 5, -8
 758              		.cfi_offset 14, -4
 759 0002 0446     		mov	r4, r0
 760              	.LVL43:
 761              	.L63:
 762 0004 2546     		mov	r5, r4
 763              	.LVL44:
 323:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****    	register char ch;
 324:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 325:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	while ((ch = *str) && (uart1_PutChar(ch) >= 0))				// Adiciona para transmissão enquanto tenha d
 764              		.loc 1 325 0 discriminator 1
 765 0006 14F8010B 		ldrb	r0, [r4], #1	@ zero_extendqisi2
 766              	.LVL45:
 767 000a 18B1     		cbz	r0, .L66
 768              		.loc 1 325 0 is_stmt 0 discriminator 2
 769 000c FFF7FEFF 		bl	uart1_PutChar
 770              	.LVL46:
 771 0010 0028     		cmp	r0, #0
 772 0012 F7DA     		bge	.L63
 773              	.L66:
 326:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****     	str++;
 327:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 328:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	return str;													// Retorna o ponteiro atual da string
 329:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** }
 774              		.loc 1 329 0 is_stmt 1
 775 0014 2846     		mov	r0, r5
 776 0016 38BD     		pop	{r3, r4, r5, pc}
 777              		.cfi_endproc
 778              	.LFE13:
 780              		.section	.text.uart1_ISR,"ax",%progbits
 781              		.align	1
 782              		.global	uart1_ISR
 783              		.thumb
 784              		.thumb_func
 786              	uart1_ISR:
 787              	.LFB14:
 330:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** #endif // FREE_RTOS
 331:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 332:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //#################################################################################################
 333:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // UART SERVIÇO DE INTERRUPÇÕES
 334:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** // 		Descrição: 	Esta função implementa o ISR da UART1
 335:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //#################################################################################################
 336:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** //#################################################################################################
 337:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** void uart1_ISR (void) {
 788              		.loc 1 337 0
 789              		.cfi_startproc
 790              		@ args = 0, pretend = 0, frame = 0
 791              		@ frame_needed = 0, uses_anonymous_args = 0
 792 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 793              	.LCFI6:
 794              		.cfi_def_cfa_offset 24
 795              		.cfi_offset 3, -24
 796              		.cfi_offset 4, -20
 797              		.cfi_offset 5, -16
 798              		.cfi_offset 6, -12
 799              		.cfi_offset 7, -8
 800              		.cfi_offset 14, -4
 338:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	ISR_ENTRY;																// Procedimento para entrada da interrupção
 339:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 340:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	u8 int_flags;
 341:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 342:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	while ( !((int_flags = U1IIR) & U1IIR_NO_INT) ) {							// Faça para todos os pedidos de interru
 801              		.loc 1 342 0
 802 0002 234E     		ldr	r6, .L87
 343:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****     	switch (int_flags & U1IIR_ID_MASK) {									// Identifica a fonte de interrupção
 344:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****     	case U1IIR_RLS_INT:                									// Caso recebeu uma INT de erro na linha de recepç
 345:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         	U1LSR;                         									// Limpa registrador de status de linha
 346:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         	break;
 347:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 348:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         // ADICIONA NO BUFFER RX OS DADOS DA FIFO
 349:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         // No modo de trigger acima de 1 byte, se a quantidade de bytes da FIFO de recepção
 350:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         	// não alcançar o nível do trigger os dados da FIFO serão adicionados
 351:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         	// ao buffer de recepção pela interrupção de timerout da UART (U3IIR_CTI_INT)
 352:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****       	case U1IIR_CTI_INT:                									// Character Timeout Indicator. Dados na FIFO RX
 353:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****       	case U1IIR_RDA_INT:                									// Caso que exista bytes disponivel recepção
 354:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****      		do { 
 355:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****       			if (buffer_AddToEnd(&u1_buf_rx, U1RBR) == errBUFFER_FULL)
 803              		.loc 1 355 0
 804 0004 234C     		ldr	r4, .L87+4
 805              	.L83:
 342:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	while ( !((int_flags = U1IIR) & U1IIR_NO_INT) ) {							// Faça para todos os pedidos de interru
 806              		.loc 1 342 0
 807 0006 3368     		ldr	r3, [r6, #0]
 808              	.LVL47:
 809 0008 DA07     		lsls	r2, r3, #31
 810 000a 3CD4     		bmi	.L69
 343:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****     	switch (int_flags & U1IIR_ID_MASK) {									// Identifica a fonte de interrupção
 811              		.loc 1 343 0
 812 000c 03F00E03 		and	r3, r3, #14
 813              	.LVL48:
 814 0010 0C2B     		cmp	r3, #12
 815 0012 32D8     		bhi	.L70
 816 0014 DFE803F0 		tbb	[pc, r3]
 817              	.L75:
 818 0018 34       		.byte	(.L85-.L75)/2
 819 0019 31       		.byte	(.L70-.L75)/2
 820 001a 2C       		.byte	(.L72-.L75)/2
 821 001b 31       		.byte	(.L70-.L75)/2
 822 001c 09       		.byte	(.L73-.L75)/2
 823 001d 31       		.byte	(.L70-.L75)/2
 824 001e 07       		.byte	(.L74-.L75)/2
 825 001f 31       		.byte	(.L70-.L75)/2
 826 0020 31       		.byte	(.L70-.L75)/2
 827 0021 31       		.byte	(.L70-.L75)/2
 828 0022 31       		.byte	(.L70-.L75)/2
 829 0023 31       		.byte	(.L70-.L75)/2
 830 0024 09       		.byte	(.L73-.L75)/2
 831 0025 00       		.align	1
 832              	.L74:
 345:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         	U1LSR;                         									// Limpa registrador de status de linha
 833              		.loc 1 345 0
 834 0026 1C4B     		ldr	r3, .L87+8
 835 0028 2BE0     		b	.L86
 836              	.L73:
 356:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 					u1_overflow_rx++;
 837              		.loc 1 356 0
 838 002a 1C4D     		ldr	r5, .L87+12
 357:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****       		} while(U1LSR & U1LSR_RDR);										// Faça enquanto existe dados validos na FIFO de recep
 839              		.loc 1 357 0
 840 002c 1A4F     		ldr	r7, .L87+8
 841              	.L81:
 355:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****       			if (buffer_AddToEnd(&u1_buf_rx, U1RBR) == errBUFFER_FULL)
 842              		.loc 1 355 0
 843 002e 2168     		ldr	r1, [r4, #0]
 844 0030 1B48     		ldr	r0, .L87+16
 845 0032 C9B2     		uxtb	r1, r1
 846 0034 FFF7FEFF 		bl	buffer_AddToEnd
 847              	.LVL49:
 848 0038 0A30     		adds	r0, r0, #10
 849 003a 03D1     		bne	.L77
 356:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 					u1_overflow_rx++;
 850              		.loc 1 356 0
 851 003c 2B88     		ldrh	r3, [r5, #0]
 852 003e 0133     		adds	r3, r3, #1
 853 0040 9BB2     		uxth	r3, r3
 854 0042 2B80     		strh	r3, [r5, #0]	@ movhi
 855              	.L77:
 856              		.loc 1 357 0
 857 0044 3B68     		ldr	r3, [r7, #0]
 858 0046 D807     		lsls	r0, r3, #31
 859 0048 F1D4     		bmi	.L81
 860 004a DCE7     		b	.L83
 861              	.L79:
 358:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 359:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 			#if (UART1_USE_HANDSHAKING == pdON) // AINDA NÃO TESTADO
 360:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****      		if (UART1_RX_BUFFER_SIZE - u1_buf_rx.datalength > UART1_SIZE_FIFO)
 361:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****      			 uart1_RTSon(); // Sinaliza que posso receber mais dados
 362:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****      		else uart1_RTSoff(); // Sinaliza que não posso receber mais dados
 363:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   			#endif
 364:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 365:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 			break;
 366:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 367:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****      	// RETIRA OS DADOS DO BUFFER TX PARA A FIFO DE TRANSMISSÃO
 368:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****      		// Essa interrupção é gerada quando a FIFO de transmissão de 16 bytes está vazia
 369:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 			// O registrador UxTHR é o topo da FIFO de 16 bytes, ou seja, é o endereço da última posição a s
 370:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****       	case U1IIR_THRE_INT:              									// Interrupção da FIFO de 16 bytes quando está va
 371:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         	while (U1LSR & U1LSR_THRE) {									// Faça enquanto há espaço na FIFO
 372:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         		if (buffer_IsEmpty(&u1_buf_tx) ) {						 	// Checa se o buffer de transmissão já está vaz
 862              		.loc 1 372 0
 863 004c 1548     		ldr	r0, .L87+20
 864 004e FFF7FEFF 		bl	buffer_IsEmpty
 865              	.LVL50:
 866 0052 40B1     		cbz	r0, .L78
 373:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         			u1_tx_running = pdFALSE;   								// Sinaliza que não existe dados para trasnmissao
 867              		.loc 1 373 0
 868 0054 144B     		ldr	r3, .L87+24
 869 0056 0022     		movs	r2, #0
 870 0058 1A70     		strb	r2, [r3, #0]
 374:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         			U1IER &= ~U1IER_ETBEI;                					// Desativa a interrupção de transmissão
 871              		.loc 1 374 0
 872 005a 144B     		ldr	r3, .L87+28
 873 005c 1A68     		ldr	r2, [r3, #0]
 874 005e 22F00202 		bic	r2, r2, #2
 875 0062 1A60     		str	r2, [r3, #0]
 375:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****          			break;
 876              		.loc 1 375 0
 877 0064 CFE7     		b	.L83
 878              	.L78:
 376:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         		} else {
 377:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 					#if (UART1_USE_HANDSHAKING == pdON) // AINDA NÃO TESTADO
 378:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	    			if (uart1_CTS()) // Checa se o receptor esteja pronto para eviar dados
 379:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 					#endif     			
 380:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         				U1THR = buffer_GetFromFront(&u1_buf_tx);			// Atribui o dado do buffer ao registrador d
 879              		.loc 1 380 0
 880 0066 0F48     		ldr	r0, .L87+20
 881 0068 FFF7FEFF 		bl	buffer_GetFromFront
 882              	.LVL51:
 883 006c 2060     		str	r0, [r4, #0]
 884 006e 00E0     		b	.L84
 885              	.L72:
 371:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         	while (U1LSR & U1LSR_THRE) {									// Faça enquanto há espaço na FIFO
 886              		.loc 1 371 0 discriminator 1
 887 0070 094D     		ldr	r5, .L87+8
 888              	.L84:
 889 0072 2B68     		ldr	r3, [r5, #0]
 890 0074 9906     		lsls	r1, r3, #26
 891 0076 E9D4     		bmi	.L79
 892 0078 C5E7     		b	.L83
 893              	.L70:
 381:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         		}
 382:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         	}
 383:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****  
 384:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         	break;
 385:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 386:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****       	case U1IIR_MS_INT:                 									// MODEM Status
 387:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         	U1MSR;                          								// Limpa o registrador de status do modem
 388:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         	break;
 389:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 390:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****       	default:															// Interrupção desconhecida
 391:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         	U1LSR;															// Limpa registrador de status de linha
 894              		.loc 1 391 0
 895 007a 074B     		ldr	r3, .L87+8
 896 007c 1B68     		ldr	r3, [r3, #0]
 392:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         	U1RBR;															// Limpa o registrador de recepçao de dados
 897              		.loc 1 392 0
 898 007e 2368     		ldr	r3, [r4, #0]
 899              	.L85:
 393:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         	U1MSR;															// Limpa o registrador de status do modem
 900              		.loc 1 393 0
 901 0080 0B4B     		ldr	r3, .L87+32
 902              	.L86:
 903 0082 1B68     		ldr	r3, [r3, #0]
 394:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****         	break;
 904              		.loc 1 394 0
 905 0084 BFE7     		b	.L83
 906              	.LVL52:
 907              	.L69:
 395:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****       	}
 396:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	}
 397:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	
 398:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	// Limpa interrupção
 399:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	#if defined(arm7tdmi)
 400:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	VICSoftIntClr = (1<<VIC_UART1);
 401:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	#endif
 402:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	#if defined (cortexm3)
 403:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	nvic_clearPendingIRQ(VIC_UART1);
 908              		.loc 1 403 0
 909 0086 0620     		movs	r0, #6
 404:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	#endif
 405:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 
 406:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c ****   	ISR_EXIT;																// Procedimento para saida da interrupção
 407:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** }
 910              		.loc 1 407 0
 911 0088 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 403:uc_libc_dev/_arch/arm_lpc/uart/uart1_irq.c **** 	nvic_clearPendingIRQ(VIC_UART1);
 912              		.loc 1 403 0
 913 008c FFF7FEBF 		b	nvic_clearPendingIRQ
 914              	.LVL53:
 915              	.L88:
 916              		.align	2
 917              	.L87:
 918 0090 08000140 		.word	1073807368
 919 0094 00000140 		.word	1073807360
 920 0098 14000140 		.word	1073807380
 921 009c 00000000 		.word	.LANCHOR4
 922 00a0 00000000 		.word	.LANCHOR0
 923 00a4 00000000 		.word	.LANCHOR2
 924 00a8 00000000 		.word	.LANCHOR5
 925 00ac 04000140 		.word	1073807364
 926 00b0 18000140 		.word	1073807384
 927              		.cfi_endproc
 928              	.LFE14:
 930              		.section	.bss.u1_tx_running,"aw",%nobits
 931              		.set	.LANCHOR5,. + 0
 934              	u1_tx_running:
 935 0000 00       		.space	1
 936              		.section	.bss.u1_overflow_rx,"aw",%nobits
 937              		.align	1
 938              		.set	.LANCHOR4,. + 0
 941              	u1_overflow_rx:
 942 0000 0000     		.space	2
 943              		.section	.bss.u1_data_rx,"aw",%nobits
 944              		.set	.LANCHOR1,. + 0
 947              	u1_data_rx:
 948 0000 00000000 		.space	300
 948      00000000 
 948      00000000 
 948      00000000 
 948      00000000 
 949              		.section	.bss.u1_buf_rx,"aw",%nobits
 950              		.align	2
 951              		.set	.LANCHOR0,. + 0
 954              	u1_buf_rx:
 955 0000 00000000 		.space	12
 955      00000000 
 955      00000000 
 956              		.section	.bss.u1_data_tx,"aw",%nobits
 957              		.set	.LANCHOR3,. + 0
 960              	u1_data_tx:
 961 0000 00000000 		.space	300
 961      00000000 
 961      00000000 
 961      00000000 
 961      00000000 
 962              		.section	.bss.u1_buf_tx,"aw",%nobits
 963              		.align	2
 964              		.set	.LANCHOR2,. + 0
 967              	u1_buf_tx:
 968 0000 00000000 		.space	12
 968      00000000 
 968      00000000 
 969              		.text
 970              	.Letext0:
 971              		.file 2 "uc_libc_dev/_libdef/uc_libdefs.h"
 972              		.file 3 "uc_libc_dev/misc/buffer.h"
 973              		.file 4 "uc_libc_dev/_arch/arm_lpc/common/vic_cortexm3.h"
DEFINED SYMBOLS
                            *ABS*:00000000 uart1_irq.c
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:19     .text.uart1_Init:00000000 $t
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:24     .text.uart1_Init:00000000 uart1_Init
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:155    .text.uart1_Init:00000098 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:173    .text.uart1_GetChar:00000000 $t
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:178    .text.uart1_GetChar:00000000 uart1_GetChar
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:248    .text.uart1_GetChar:00000040 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:254    .text.uart1_ClearBufferRx:00000000 $t
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:259    .text.uart1_ClearBufferRx:00000000 uart1_ClearBufferRx
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:301    .text.uart1_ClearBufferRx:0000002c $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:309    .text.uart1_CountRxOverflow:00000000 $t
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:314    .text.uart1_CountRxOverflow:00000000 uart1_CountRxOverflow
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:337    .text.uart1_CountRxOverflow:0000000c $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:342    .text.uart1_BufferRxIsEmpty:00000000 $t
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:347    .text.uart1_BufferRxIsEmpty:00000000 uart1_BufferRxIsEmpty
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:366    .text.uart1_BufferRxIsEmpty:00000010 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:371    .text.uart1_BufferQtdRx:00000000 $t
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:376    .text.uart1_BufferQtdRx:00000000 uart1_BufferQtdRx
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:392    .text.uart1_BufferQtdRx:00000008 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:397    .text.uart1_GetBufferRx:00000000 $t
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:402    .text.uart1_GetBufferRx:00000000 uart1_GetBufferRx
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:415    .text.uart1_GetBufferRx:00000004 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:420    .text.uart1_PutChar:00000000 $t
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:425    .text.uart1_PutChar:00000000 uart1_PutChar
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:516    .text.uart1_PutChar:00000058 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:524    .text.uart1_BasicPutChar:00000000 $t
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:529    .text.uart1_BasicPutChar:00000000 uart1_BasicPutChar
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:555    .text.uart1_BasicPutChar:00000014 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:561    .text.uart1_SpaceTx:00000000 $t
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:566    .text.uart1_SpaceTx:00000000 uart1_SpaceTx
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:605    .text.uart1_SpaceTx:00000024 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:611    .text.uart1_FlushTx:00000000 $t
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:616    .text.uart1_FlushTx:00000000 uart1_FlushTx
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:645    .text.uart1_FlushTx:00000018 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:651    .text.uart1_EmptyTx:00000000 $t
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:656    .text.uart1_EmptyTx:00000000 uart1_EmptyTx
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:675    .text.uart1_EmptyTx:00000014 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:680    .text.uart1_WriteTx:00000000 $t
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:685    .text.uart1_WriteTx:00000000 uart1_WriteTx
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:740    .text.uart1_PutString:00000000 $t
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:745    .text.uart1_PutString:00000000 uart1_PutString
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:781    .text.uart1_ISR:00000000 $t
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:786    .text.uart1_ISR:00000000 uart1_ISR
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:818    .text.uart1_ISR:00000018 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:918    .text.uart1_ISR:00000090 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:934    .bss.u1_tx_running:00000000 u1_tx_running
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:935    .bss.u1_tx_running:00000000 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:937    .bss.u1_overflow_rx:00000000 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:941    .bss.u1_overflow_rx:00000000 u1_overflow_rx
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:947    .bss.u1_data_rx:00000000 u1_data_rx
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:948    .bss.u1_data_rx:00000000 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:950    .bss.u1_buf_rx:00000000 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:954    .bss.u1_buf_rx:00000000 u1_buf_rx
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:960    .bss.u1_data_tx:00000000 u1_data_tx
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:961    .bss.u1_data_tx:00000000 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:963    .bss.u1_buf_tx:00000000 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:967    .bss.u1_buf_tx:00000000 u1_buf_tx
                     .debug_frame:00000010 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:831    .text.uart1_ISR:00000025 $d
C:\Users\alex\AppData\Local\Temp\ccDEmYor.s:831    .text.uart1_ISR:00000026 $t

UNDEFINED SYMBOLS
nvic_enableIRQ
nvic_setPriority
buffer_Init
buffer_GetFromFront
buffer_Clear
buffer_AddToEnd
buffer_IsEmpty
nvic_clearPendingIRQ
